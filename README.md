# lokitServer
基于事件驱动HTTP服务器设计

## 综述
- 采用主-从 reactor 模式分发监听套接字和连接套接字的事件，以线程池的方式实现多线程，并解决主线程等待子线程全部初始化完成、及主线程如何解除子线程阻塞状态的问题
- 非阻塞I/O，在应用层实现缓冲区管理，包括管理待发送/接收的数据，动态扩容
- 服务端的每个线程维护记录每个连接客户端的哈希表，便于动态处理客户端的连接建立状态和断开状态
- 基于回调函数机制，在下层的网络I/O处理中添加可hook-point，为上层提供接口；解耦上层的逻辑处理和下层的网络I/O处理
- 在每个子线程的处理中，基于event loop, 采用poll/epoll事件分发和回调函数处理连接套接字的I/O。采用基于事件驱动的I/O多路复用，保证可扩展性

## 数据缓冲区
The addition of non-blocking I/O complicates the function’s buffer management noticeably. 
非阻塞I/O的特点是partial read和partial write，需要注意上一轮没有读完的数据在缓冲区内且不能被接下来的写覆盖，因此缓冲区会管理两块空间：分别对应读和写。
- 在往对端发送数据时，如果要发送数据的大小当前大于TCP发送缓冲区的空闲大小，则write函数返回后，应用层仍有未完全发送出去的数据。此时，可将这部分数据接由应用层的缓冲区管理 

## 多线程机制
- 初始的时候只有监听线程（主线程），子线程负责处理网络I/O。每个子线程有一个事件队列，每次会扫描一遍事件队列，将队列中的连接套接字添加到epoll集合中。每当一个客户端建立连接时，主线程负责分发连接套接字到各个子线程中，子线程通过调用epoll_add将 然后每个子线程会在多个连接套接字上进行I/O多路复用。
- 子线程创建后，因为负责网络I/O，但此时若没有连接建立，子线程会阻塞在调用的epoll/poll上，那么即便主线程将事件分发到子线程事件队列中，子线程也无法从阻塞中唤醒。因此需要主线程通知子线程从epoll/poll调用中返回。于是就在主线程和子线程间维护一个unix域套接字，子线程最开始在该套接字上阻塞，一旦有连接套接字产生，就往该套接字写数据
